# Stack Watcher データ取得アーキテクチャ設計書

## 1. 概要

### 1.1 基本方針
- データベースを使用せず、外部APIからリアルタイムでデータを取得
- 必要最小限のキャッシュによるパフォーマンス最適化
- 複数データソースの統合とフォールバック機能

### 1.2 対象データ
- **株価データ**: クボタ(6326)、ソフトバンク(9984)、サカタのタネ(1377)
- **インデックスデータ**: 日経225、TOPIX、マザーズ指数
- **気象データ**: 降水量、気温、気圧（東京都）

## 2. 利用可能な株価データAPI

### 2.1 推奨API（無料）

#### 2.1.1 🥇 Alpha Vantage
- **URL**: https://www.alphavantage.co/
- **無料枠**: 25リクエスト/日（API KEY必要）
- **日本株対応**: ○（東証銘柄対応）
- **データ形式**: JSON/CSV
- **遅延**: 15-20分遅延
- **利用方法**:
```
https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=6326.T&apikey=YOUR_API_KEY
```

#### 2.1.2 🥈 Yahoo Finance API (非公式)
- **ライブラリ**: `yfinance` (Python)
- **無料枠**: 制限なし（利用規約に注意）
- **日本株対応**: ○（.T サフィックス）
- **データ形式**: pandas DataFrame
- **遅延**: 15-20分遅延
- **利用方法**:
```python
import yfinance as yf
ticker = yf.Ticker("6326.T")
data = ticker.history(period="7d")
```

#### 2.1.3 🥉 Stooq
- **URL**: https://stooq.com/
- **無料枠**: 制限なし
- **日本株対応**: ○
- **データ形式**: CSV
- **遅延**: 15-20分遅延
- **利用方法**:
```
https://stooq.com/q/d/l/?s=6326.jp&f=sd2t2ohlcv&h&e=csv
```

### 2.2 その他の選択肢

#### Financial Modeling Prep
- **無料枠**: 250リクエスト/日
- **日本株対応**: ○
- **URL**: https://financialmodelingprep.com/

#### Twelve Data
- **無料枠**: 800リクエスト/日
- **日本株対応**: ○
- **URL**: https://twelvedata.com/

## 3. 気象データAPI

### 3.1 推奨API

#### 3.1.1 🥇 気象庁API（日本気象協会）
- **URL**: https://www.jma.go.jp/bosai/forecast/
- **無料枠**: 制限なし
- **データ**: 天気予報、降水量、気温、気圧
- **利用方法**:
```
https://www.jma.go.jp/bosai/forecast/data/forecast/130000.json
```

#### 3.1.2 🥈 OpenWeatherMap
- **URL**: https://openweathermap.org/
- **無料枠**: 1000リクエスト/日
- **データ**: 現在・履歴・予報データ
- **利用方法**:
```
https://api.openweathermap.org/data/2.5/weather?q=Tokyo&appid=YOUR_API_KEY
```

## 4. 推奨アーキテクチャ

### 4.1 データソース選択

#### Phase 1 MVP（推奨構成）
```python
# 株価データ
PRIMARY: yfinance (Yahoo Finance)
FALLBACK: Alpha Vantage

# 気象データ  
PRIMARY: 気象庁API
FALLBACK: OpenWeatherMap
```

### 4.2 理由
- **yfinance**: 無料で制限が緩く、日本株対応が良い
- **気象庁API**: 日本の公式データで信頼性が高い
- **フォールバック**: 主要APIがダウンした場合の冗長性

## 5. システム構成

### 5.1 アプリケーション構成
```
Frontend (Vue.js)
    ↓ HTTP Request
Backend (FastAPI)
    ├── Stock Service
    │   ├── Yahoo Finance Client
    │   └── Alpha Vantage Client (Fallback)
    ├── Weather Service  
    │   ├── JMA Client
    │   └── OpenWeather Client (Fallback)
    └── Cache Layer (Redis/Memory)
```

### 5.2 キャッシュ戦略

#### 5.2.1 キャッシュ期間
```python
CACHE_PERIODS = {
    "stock_data": 900,      # 15分（市場データ更新間隔）
    "weather_data": 1800,   # 30分（気象データ更新間隔）
    "symbols_master": 86400 # 24時間（マスタデータ）
}
```

#### 5.2.2 キャッシュキー設計
```python
# 株価データ
"stock:{symbol}:{period}:{date}"
# 例: "stock:6326:7d:2025-09-20"

# 気象データ
"weather:{location}:{date}"
# 例: "weather:tokyo:2025-09-20"
```

## 6. 実装設計

### 6.1 バックエンド実装

#### 6.1.1 Stock Service
```python
# backend/services/stock_service.py
import yfinance as yf
import requests
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import asyncio

class StockService:
    def __init__(self):
        self.alpha_vantage_key = os.getenv("ALPHA_VANTAGE_API_KEY")
        self.symbols_map = {
            "6326": "6326.T",  # クボタ
            "9984": "9984.T",  # ソフトバンク
            "1377": "1377.T"   # サカタのタネ
        }
    
    async def get_stock_data(self, symbol: str, period: str) -> Dict:
        """株価データ取得（プライマリ: yfinance）"""
        try:
            return await self._get_yahoo_finance_data(symbol, period)
        except Exception as e:
            print(f"Yahoo Finance failed: {e}")
            return await self._get_alpha_vantage_data(symbol, period)
    
    async def _get_yahoo_finance_data(self, symbol: str, period: str) -> Dict:
        """Yahoo Finance からデータ取得"""
        yahoo_symbol = self.symbols_map.get(symbol)
        if not yahoo_symbol:
            raise ValueError(f"Unsupported symbol: {symbol}")
        
        # 非同期実行のため executor を使用
        loop = asyncio.get_event_loop()
        ticker = yf.Ticker(yahoo_symbol)
        data = await loop.run_in_executor(
            None, 
            lambda: ticker.history(period=period)
        )
        
        return self._format_stock_data(symbol, data)
    
    async def _get_alpha_vantage_data(self, symbol: str, period: str) -> Dict:
        """Alpha Vantage からデータ取得（フォールバック）"""
        if not self.alpha_vantage_key:
            raise ValueError("Alpha Vantage API key not configured")
        
        url = f"https://www.alphavantage.co/query"
        params = {
            "function": "TIME_SERIES_DAILY",
            "symbol": f"{symbol}.T",
            "apikey": self.alpha_vantage_key
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params)
            data = response.json()
            
        return self._format_alpha_vantage_data(symbol, data)
    
    def _format_stock_data(self, symbol: str, data) -> Dict:
        """データフォーマット統一"""
        formatted_data = []
        for date, row in data.iterrows():
            formatted_data.append({
                "date": date.isoformat(),
                "open": float(row["Open"]),
                "high": float(row["High"]),
                "low": float(row["Low"]),
                "close": float(row["Close"]),
                "volume": int(row["Volume"])
            })
        
        return {
            "symbol": symbol,
            "company_name": self._get_company_name(symbol),
            "data_points": formatted_data
        }
```

#### 6.1.2 Weather Service
```python
# backend/services/weather_service.py
import httpx
from typing import Dict
import asyncio

class WeatherService:
    def __init__(self):
        self.openweather_key = os.getenv("OPENWEATHER_API_KEY")
        self.jma_base_url = "https://www.jma.go.jp/bosai"
    
    async def get_weather_data(self, location: str = "tokyo") -> Dict:
        """気象データ取得（プライマリ: 気象庁）"""
        try:
            return await self._get_jma_data()
        except Exception as e:
            print(f"JMA API failed: {e}")
            return await self._get_openweather_data(location)
    
    async def _get_jma_data(self) -> Dict:
        """気象庁データ取得"""
        url = f"{self.jma_base_url}/forecast/data/forecast/130000.json"
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url)
            data = response.json()
            
        return self._format_jma_data(data)
    
    async def _get_openweather_data(self, location: str) -> Dict:
        """OpenWeatherMap データ取得（フォールバック）"""
        if not self.openweather_key:
            raise ValueError("OpenWeather API key not configured")
        
        url = "https://api.openweathermap.org/data/2.5/weather"
        params = {
            "q": location,
            "appid": self.openweather_key,
            "units": "metric"
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params)
            data = response.json()
            
        return self._format_openweather_data(data)
```

### 6.2 API エンドポイント更新

#### 6.2.1 環境変数設定
```python
# backend/config.py
import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    # API Keys
    alpha_vantage_api_key: str = ""
    openweather_api_key: str = ""
    
    # Cache settings
    cache_backend: str = "memory"  # "memory" | "redis"
    redis_url: str = "redis://localhost:6379"
    
    # Rate limiting
    rate_limit_per_minute: int = 60
    
    class Config:
        env_file = ".env"

settings = Settings()
```

#### 6.2.2 キャッシュ実装
```python
# backend/cache/cache_manager.py
from typing import Optional, Any
import json
import time
from abc import ABC, abstractmethod

class CacheBackend(ABC):
    @abstractmethod
    async def get(self, key: str) -> Optional[str]:
        pass
    
    @abstractmethod  
    async def set(self, key: str, value: str, expire: int) -> None:
        pass

class MemoryCache(CacheBackend):
    def __init__(self):
        self._cache = {}
    
    async def get(self, key: str) -> Optional[str]:
        item = self._cache.get(key)
        if item and item["expire"] > time.time():
            return item["value"]
        elif item:
            del self._cache[key]
        return None
    
    async def set(self, key: str, value: str, expire: int) -> None:
        self._cache[key] = {
            "value": value,
            "expire": time.time() + expire
        }

class CacheManager:
    def __init__(self, backend: CacheBackend):
        self.backend = backend
    
    async def get_or_set(self, key: str, factory, expire: int = 3600):
        """キャッシュから取得、なければ factory で生成してキャッシュ"""
        cached = await self.backend.get(key)
        if cached:
            return json.loads(cached)
        
        # データ生成
        data = await factory()
        await self.backend.set(key, json.dumps(data), expire)
        return data
```

## 7. パフォーマンス最適化

### 7.1 並列処理
```python
# 複数銘柄の並列取得
async def get_multiple_stocks(symbols: List[str], period: str) -> Dict:
    tasks = [
        stock_service.get_stock_data(symbol, period) 
        for symbol in symbols
    ]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    stocks = []
    for symbol, result in zip(symbols, results):
        if isinstance(result, Exception):
            print(f"Failed to get data for {symbol}: {result}")
            continue
        stocks.append(result)
    
    return {"stocks": stocks}
```

### 7.2 レート制限対応
```python
# backend/middleware/rate_limiter.py
import time
from collections import defaultdict
from fastapi import HTTPException, Request

class RateLimiter:
    def __init__(self, max_requests: int = 60, window: int = 60):
        self.max_requests = max_requests
        self.window = window
        self.requests = defaultdict(list)
    
    def is_allowed(self, client_ip: str) -> bool:
        now = time.time()
        # 古いリクエストを削除
        self.requests[client_ip] = [
            req_time for req_time in self.requests[client_ip]
            if now - req_time < self.window
        ]
        
        if len(self.requests[client_ip]) >= self.max_requests:
            return False
        
        self.requests[client_ip].append(now)
        return True
```

## 8. 運用・監視

### 8.1 ヘルスチェック拡張
```python
# backend/api/health.py
@router.get("/health")
async def health_check():
    checks = {
        "yahoo_finance": await check_yahoo_finance(),
        "alpha_vantage": await check_alpha_vantage(),
        "jma_api": await check_jma_api(),
        "cache": await check_cache()
    }
    
    all_healthy = all(check["status"] == "healthy" for check in checks.values())
    
    return {
        "status": "healthy" if all_healthy else "degraded",
        "services": checks,
        "timestamp": datetime.utcnow().isoformat()
    }
```

### 8.2 エラーハンドリング
```python
# 段階的フォールバック
async def get_data_with_fallback(symbol: str, period: str):
    providers = [
        ("yahoo_finance", lambda: get_yahoo_data(symbol, period)),
        ("alpha_vantage", lambda: get_alpha_vantage_data(symbol, period)),
        ("mock_data", lambda: get_mock_data(symbol, period))
    ]
    
    for provider_name, provider_func in providers:
        try:
            data = await provider_func()
            return data
        except Exception as e:
            print(f"{provider_name} failed: {e}")
            continue
    
    raise Exception("All data providers failed")
```

## 9. 開発環境設定

### 9.1 環境変数（.env）
```bash
# Stock Data APIs
ALPHA_VANTAGE_API_KEY=your_alpha_vantage_key
OPENWEATHER_API_KEY=your_openweather_key

# Cache
CACHE_BACKEND=memory
REDIS_URL=redis://localhost:6379

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60

# Development
DEBUG=true
LOG_LEVEL=INFO
```

### 9.2 依存関係（requirements.txt）
```
# Core
fastapi==0.103.0
uvicorn==0.23.0
pydantic==2.4.0

# Stock Data
yfinance==0.2.18
httpx==0.25.0
pandas==2.1.0

# Cache (optional)
redis==5.0.0

# Development
pytest==7.4.0
pytest-asyncio==0.21.0
```

## 10. API制限と対策

### 10.1 制限一覧
| API | 無料枠 | 制限対策 |
|-----|--------|----------|
| yfinance | 実質無限 | レート制限実装 |
| Alpha Vantage | 25req/日 | キャッシュ活用 |
| 気象庁 | 制限なし | - |
| OpenWeather | 1000req/日 | フォールバック用 |

### 10.2 コスト最適化
- **キャッシュの活用**: 15分間のデータキャッシュでAPI呼び出しを削減
- **バッチ処理**: 複数銘柄の一括取得
- **フォールバック**: 無料APIの組み合わせで冗長性確保

---

**作成日**: 2025年9月20日  
**バージョン**: 1.0  
**対象フェーズ**: Phase 1 MVP